/*
 * MM JDBC Drivers for MySQL
 *
 * $Id: Statement.java,v 1.4 2002/04/25 01:10:49 mark_matthews Exp $
 *
 * Copyright (C) 1998 Mark Matthews <mmatthew@worldserver.com>
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA  02111-1307, USA.
 *
 * See the COPYING file located in the top-level-directory of
 * the archive of this library for complete text of license.
 *
 * Some portions:
 *
 * Copyright (c) 1996 Bradley McLean / Jeffrey Medeiros
 * Modifications Copyright (c) 1996/1997 Martin Rode
 * Copyright (c) 1997 Peter T Mount
 */

/**
 * A Statement object is used for executing a static SQL statement and
 * obtaining the results produced by it.
 *
 * <p>Only one ResultSet per Statement can be open at any point in time.
 * Therefore, if the reading of one ResultSet is interleaved with the
 * reading of another, each must have been generated by different
 * Statements.  All statement execute methods implicitly close a
 * statement's current ResultSet if an open one exists.
 *
 * @see java.sql.Statement
 * @see ResultSet
 * @author Mark Matthews <mmatthew@worldserver.com>
 * @version $Id: Statement.java,v 1.4 2002/04/25 01:10:49 mark_matthews Exp $
 */

package org.gjt.mm.mysql.jdbc2;

import java.sql.*;
import java.util.Vector;

import org.gjt.mm.mysql.Field;

public class Statement
	extends org.gjt.mm.mysql.Statement
	implements java.sql.Statement {

	/**
	 * Constructor for a Statement.  It simply sets the connection
	 * that created us.
	 *
	 * @param c the Connection instantation that creates us
	 */

	public Statement(Connection C, String Catalog) {
		super(C, Catalog);
	}

	/**
	 * Execute a SQL statement that retruns a single ResultSet
	 *
	 * @param Sql typically a static SQL SELECT statement
	 * @return a ResulSet that contains the data produced by the query
	 * @exception java.sql.SQLException if a database access error occurs
	 */

	public java.sql.ResultSet executeQuery(String Sql)
		throws java.sql.SQLException {
		return super.executeQuery(Sql);
	}

	/**
	 * Execute a SQL INSERT, UPDATE or DELETE statement.  In addition
	 * SQL statements that return nothing such as SQL DDL statements
	 * can be executed
	 *
	 * Any IDs generated for AUTO_INCREMENT fields can be retrieved
	 * by casting this Statement to org.gjt.mm.mysql.Statement and
	 * calling the getLastInsertID() method.
	 *
	 * @param Sql a SQL statement
	 * @return either a row count, or 0 for SQL commands
	 * @exception java.sql.SQLException if a database access error occurs
	 */

	public int executeUpdate(String Sql) throws java.sql.SQLException {
		return super.executeUpdate(Sql);
	}

	/**
	 * Execute a SQL statement that may return multiple results. We
	 * don't have to worry about this since we do not support multiple
	 * ResultSets.   You can use getResultSet or getUpdateCount to
	 * retrieve the result.
	 *
	 * @param sql any SQL statement
	 * @return true if the next result is a ResulSet, false if it is
	 *      an update count or there are no more results
	 * @exception java.sql.SQLException if a database access error occurs
	 */

	public boolean execute(String Sql) throws java.sql.SQLException {
		return super.execute(Sql);
	}

	/**
	 * Sets the result set type for result sets generated by this statement
	 */

	void setResultSetType(int typeFlag) {
		_resultSetType = typeFlag;
	}

	/**
	 * Sets the concurrency for result sets generated by this statement
	 */

	void setResultSetConcurrency(int concurrencyFlag) {
		_resultSetConcurrency = concurrencyFlag;
	}

	/**
	* JDBC 2.0
	* 
	* Submit a batch of commands to the database for execution.
	* This method is optional.
	*
	* @return an array of update counts containing one element for each
	* command in the batch.  The array is ordered according 
	* to the order in which commands were inserted into the batch
	* @exception SQLException if a database-access error occurs, or the
	* driver does not support batch statements
	*/

	public int[] executeBatch() throws SQLException {

		try {
			int[] updateCounts = null;

			if (_batchedArgs != null) {

				int nbrCommands = _batchedArgs.size();
				updateCounts = new int[nbrCommands];

				for (int i = 0; i < nbrCommands; i++) {
					updateCounts[i] = -3;
				}

				SQLException sqlEx = null;

				for (int i = 0; i < nbrCommands; i++) {
					try {
						updateCounts[i] = executeUpdate((String) _batchedArgs.elementAt(i));
					}
					catch (SQLException ex) {
						sqlEx = ex;
					}
				}

				if (sqlEx != null) {
					throw new java.sql.BatchUpdateException(
						sqlEx.getMessage(),
						sqlEx.getSQLState(),
						sqlEx.getErrorCode(),
						updateCounts);
				}
			}

			return updateCounts != null ? updateCounts : new int[0];
		}
		finally {
			clearBatch();
		}

	}
	
	public java.sql.ResultSet getGeneratedKeys() throws SQLException
	{
		Field[] fields = new Field[1];
		
		fields[0] = new Field("", "GENERATED_KEY", Types.INTEGER, 17);
		
		Vector rowSet = new Vector();
		
		byte[][] row = new byte[1][];
		
		row[0] = Long.toString(getLastInsertID()).getBytes();
		
		rowSet.addElement(row);
		
		return new org.gjt.mm.mysql.jdbc2.ResultSet(fields, rowSet, _conn);
	}
}
