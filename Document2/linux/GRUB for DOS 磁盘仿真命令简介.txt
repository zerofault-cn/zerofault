GRUB for DOS 磁盘仿真命令简介 
http://www.aoxiangnet.cn  2006-3-6 16:23:51  

在进入正题之前，先看看 GRUB for DOS 各系列版本的差异。 
GRUB for DOS 0.0.x 系列是没有任何磁盘仿真扩展功能的版本，功能上完全等价于 GNU GRUB。这里说明，GNU GRUB 本身就有磁盘映射功能。磁盘映射是一种特殊的磁盘仿真。磁盘映射只能把一个 BIOS 磁盘号码映射到另外一个 BIOS 磁盘号码，也就是说，它只能整盘整盘地仿真，不能用磁盘中的一个文件来仿真另外一个磁盘。这个版本也是最安全可靠的，可以认为，GNU GRUB 有多安全，GRUB for DOS 0.0.x 就有多安全。 
GRUB for DOS 0.1.x 系列具有 0.0.x 的全部功能，除此之外还具有软盘仿真扩展。但是只能用硬盘上的 img 文件来仿真 1.44M 的软盘，并且对软盘映象进行了写保护，也就是说禁止软件通过 int13 接口写入软盘的映象。这个版本也没有已知的安全问题。 
GRUB for DOS 0.2.x 系列增加了任意规格的软盘和硬盘的仿真功能，是功能上比较完善的版本。它和 0.1.x 系列的最大不同之处是，它默认时不再保护被仿真的磁盘映像。如果想获得与 0.1.x 等价的功能，必须为 map 命令加上 --read-only 参数。【注：0.1.x 系列也支持 --read-only 参数，但即使没有这个参数，0.1.x 系列也会自动保护磁盘映象不被写入。】 
版本 0.2.x 虽然支持写入虚拟磁盘映象，但是，格式化虚拟磁盘映象的 int13/AH=05h 功能并未完整实现。当格式化磁道的时候，GRUB for DOS 0.2.x 并不真的采取任何实质性的格式化动作，也即，它并不改变虚拟磁盘中的任何扇区的内容，而仅仅立即返回“格式化成功”的（类似于 fake write 的虚假）消息给调用者。这没有太大的问题。只有一点需要注意：当您在 DOS/Win98 下要格式化虚拟磁盘的时候，您先不要忙着下达格式化命令，而是要首先运行删除命令，将虚拟磁盘根目录下的所有文件以及所有目录都删去，变成一个空盘，然后再下达格式化命令，这样，格式化后的虚拟磁盘能够正常使用。否则，格式化之前的垃圾目录项仍然在残存着，这将影响虚拟盘的正常使用。 
由于版本 0.2.x 支持写入虚拟磁盘，所以，对虚拟磁盘边界的检查是必不可少的一个步骤了。程序已经对此作了保护。当试图读取或者写入超过虚拟磁盘边界的那些扇区的时候，int13 接口会返回失败信息“扇区未找到”，而不是真的读取或者写入（！！）硬盘上紧接着虚拟磁盘映象后面的扇区内容。【读取这些越界的扇区，并无实质性的危险；但写入这些越界的扇区，将给硬盘带来灾难。所以这个保护是必须的。】 
有关 GRUB for DOS 0.0.x 系列的说明文档，请看这里： DOS下用GRUB.EXE修复启动故障 
有关 GRUB for DOS 0.1.x 系列的说明文档，请看这里： 用 GRUB 来引导软盘映象――节约软盘介质了 
从这里下载 GRUB for DOS： http://newdos.yginfo.net/grubdos.htm （英文主页，感谢 Wengier！） ftp://211.100.7.71/incoming/ 也即： ftp://ftp.cosoft.org.cn/incoming/ 

接下来，本文只讨论 GRUB for DOS 0.2.x 系列的新功能。 
首先，安全的考虑。在版本 0.1.x 的时候，由于只仿真了软盘，并且以只读的方式访问，所以，安全问题不很重要。然而，0.2.x 大大不同了，它不仅可以写入软盘，并且默认就打开了这个功能。所以，如果您不注意的话，您有可能因此而遇到麻烦。大致有以下几种情况： 
一、如果您的程序（或者病毒）要写入软盘，那么您的软盘映象可能会改变内容，这可能不是您想要的结果。 
二、如果您仿真了硬盘，进入 Windows98 之后，硬盘的号码可能会发生错位【比如 BIOS 磁盘 0x81 变成了 0x82 等等】。这时候如果写入了硬盘映象，可能导致另外一个真实硬盘被破坏掉。这里看到，如果加上 --read-only 参数，安全性仍然可以得到比较好的保障。 
三、即使如上述“二”所说加上了只读参数，也仍然存在一定的安全隐患，其原因是，Win98 将我们的 int13 仿真程序当作病毒来对待【在 www.google.com 中查找 MBRint13 就可以找到这类信息】，因此，win98 有可能故意产生某些错误来破坏我们的 int13 的运作。迄今为止并未发现“在加上只读参数后，Win98 仍然破坏磁盘映象”的现象，但也不能保证绝对安全。 
四、在整盘映射的情况，加上 --read-only 参数之后，被仿真的磁盘在 DOS 下是只读的，但是在 win98 下不是只读的。这是因为 win98 对于“整盘映射”实施的是“32位磁盘存取”【应当叫做“保护模式磁盘存取”】，它不使用 BIOS，因此它不知道我们加上了 --read-only 参数，所以它会写入磁盘。有鉴于此，所以，在整盘映射的情况下不要使用 --read-only 参数【当然，使用 --read-only 参数并无任何坏处】。 
五、如果没有对硬盘进行仿真，也就是说仅仅使用了类似于 map DESTINATION (fd0) 的软盘仿真命令，那么，在 DOS 下应当是比较安全的。然而，如果要在仿真之后运行 win98，请注意这样一个顺序：首先用 map --read-only DESTINATION (fd0) 来运行，当您能够确认 win98 可以正常读出仿真软盘的内容之后，下一次运行 map 命令的时候就可以不再添加 --read-only 参数了。如果不能读出仿真软盘的内容，那就说明读错了位置【可能读出的是别的磁盘上的扇区】，这预示着“写入仿真软盘”将会带来灾难。所以建议在运行 win98 时先用 --read-only 参数进行确认，保证安全。 
对于版本 0.2.x 来说，如果某个问题只是引起“死机”，这不被认为是安全问题。只有当某个磁盘扇区被破坏掉了的时候，才算作安全问题。 
使用软盘仿真的情况较多，所以，主要用软盘仿真的例子来说明磁盘仿真命令的用法。 

1。把硬盘上某个盘符（例如 C:）仿真为 A:，并从 C: 盘引导 win98： 
map --read-only (hd0,0)+1 (fd0) 
chainloader (hd0,0)+1 
rootnoverify (hd0) 
boot 
上述 (hd0,0) 是 Win98 下的 C: 盘。进入 Win98 后可以发现，现在 A: 盘的内容跟 C: 盘完全一样。这时，如果随意在 A: 盘上删除文件，会导致 C: 盘也删除该文件，因而有可能引起故障（例如死机）。 
在 map 命令中，(hdm,n)+1 被解释为代表整个 (hdm,n) 分区，而不仅仅是代表分区的第一个扇区。相比之下，在其它地方，(hdm,n)+1 仍然只代表分区的第一扇区。 

2。把硬盘上某个盘符（例如 C:）仿真为 A:，并从 A: 盘引导 win98： 
map --read-only (hd0,0)+1 (fd0) 
map --hook 
chainloader (fd0)+1 
rootnoverify (fd0) 
boot 
此处需要用 map --hook 命令激活 A: 盘的就地仿真。如果没有 map --hook 命令，那么后续的 chainloader (fd0)+1 命令就要寻找真实软驱的软盘介质上的内容，而不是我们想要的虚拟软盘上的内容。 
最后一条 rootnoverify (fd0) 告诉引导程序说，我们是从软盘启动机器的。 

3。把硬盘上某个 img 文件仿真为 A:，并从 C: 盘引导 win98 
map --read-only (hd0,0)/file.img (fd0) 
chainloader (hd0,0)+1 
rootnoverify (hd0) 
boot 

4。把硬盘上某个软盘 img 文件仿真为 A:，并用该 img 映象里面的文件 dos.img 来引导机器： 
map --read-only (hd0,0)/file.img (fd0) 
map --hook 
chainloader (fd0)/dos.img 
rootnoverify (fd0) 
boot 
此处，file.img 是 C: 盘上的一个软盘映像文件，在这个映象文件中，包含了一个叫做 dos.img 的文件。如果不用 map --hook 命令（该命令启用了就地仿真功能），则无法在后续的 grub 命令行中访问 dos.img 文件。这个例子只是说明 map --hook 命令的作用，我们通常是不会用到这个例子中的方法的。 
上述命令中，软盘可以是任意的规格，任意的大小。 

下面举一个硬盘仿真的例子，但是最好不要启动 win98，而应当只限于启动 DOS： 
map --read-only (hd2,6)+1 (hd0) 
map --hook 
chainloader (hd0,0)+1 
rootnoverify (hd0) 
boot 
这里，(hd2,6)+1 是第三块硬盘上的某个逻辑 DOS 分区。“map (hd2,6)+1 (hd0)”命令将扩展 DOS 分区仿真为 BIOS 的 0x80 号硬盘。激活就地仿真【map --hook】之后，“chainloader (hd0,0)+1”中的 (hd0,0)+1 就是仿真之后的虚拟 0x80 硬盘分区，而不是仿真之前的 0x80 号硬盘分区了。【此处的 (hd0,0)+1 实际上就是仿真之前的 (hd2,6)+1】。您应当保证这时在该分区中存在着 DOS，否则引导会失败。如果您不启动 win98，可以不用 --read-only 参数。如果试图启动 win98，通常会引导失败。 
因为 MS-DOS 的逻辑分区之前的 63 个扇区处，都存放了一个“扩展分区的分区表”，所以有可能用它来仿真一个硬盘。“扩展分区表”中的引导记录全都是 00 字节。GRUB for DOS 0.2.x 在读取这个分区表的时候，作了一些修改，使得这个表看起来像是一个合法的硬盘主分区表。GRUB for DOS 并不写入该扇区，因为默认的 safeboot 在起作用。这是安全的。在这种情况下不应当加入 --unsafe-boot 选项，因为 win98 会随意写入虚拟磁盘的引导扇区，这将导致该分区表信息的错位，造成扩展分区不可访问的后果【内容还在，只是扩展分区表错误导致不可访问。手动修改扩展分区表可以解决这个问题，但需要计算准确】。 

上述硬盘仿真的例子，如果改成下面的方式，这将是失败的： 
map --read-only (hd2,6)+1 (hd0) 
chainloader (hd2,6)+1 
rootnoverify (hd0) 
boot 
分区 (hd2,6) 的 DOS 引导记录中有一个“隐含扇区”的字段，这个字段必须修改。如果没有 map --hook 命令，该字段不会被正确修改，因而将导致引导失败。修改该字段的程序，是在 int13 的中断处理程序中，所以需要 map --hook 之后再读出该扇区的内容【此时所读出的该扇区内容已经经过恰当修改了】。在 map --hook 之后，应当使用 chainloader (hd0,0)+1 来装入仿真之前的 (hd2,6)+1，直接用 chainloader (hd2,6)+1 是错误的【直接用 chainloader (hd2,6)+1 结果，使得该扇区不能利用 int13 的中断处理程序进行必要的修改，这将导致引导失败】。注意，int13 仅对磁盘 (hd0) 起作用，对 (hd2) 不起作用，这是因为 map --read-only (hd2,6)+1 (hd0) 命令只对 (hd0) 进行了仿真，而对其它磁盘【包括(hd2)】都没有进行仿真。所以，int13 程序会修改 (hd0,0)+1 但不修改 (hd2,6)+1。 
又，上述“修改”并不发生在磁盘上，而是发生在内存中。所以，磁盘上的扇区内容不会改变。也就是说，当读取该扇区的时候，要对读出的扇区进行修改，从而保证扇区内容可用；而当写入扇区的时候，由于默认的 safeboot 在起作用，所以，不会有写入的动作，直接返回虚假的“写入成功”的消息。 
前面已经解释过了，safeboot 只保护硬盘 MBR 主引导扇区以及硬盘第一个主分区的第一个扇区（通常是 DOS 的引导扇区）――只保护这两个扇区，不保护其它扇区。 
GRUB for DOS 0.2.0 还包括了 BOOTGRUB 和 GRLDR 文件【它们叫做“GRUB for NTLDR”】。这两个文件用于从 Windows NT/2000/XP/2003 的引导菜单中直接启动 GRUB。用法是，将 BOOTGRUB 和 GRLDR 拷贝到 Windows NT/2000/XP/2003 的 C: 盘根目录【C:盘根目录下应当有隐藏的 NTLDR 和 BOOT.INI 文件】，然后修改 BOOT.INI 文件，一般是在 BOOT.INI 文件尾部添加类似如下的一行： 
C:\BOOTGRUB="启动GRUB" 
重新启动机器，选择相应的菜单项就进入 GRUB 了。 
安全建议（这是以前写的，现在还保留它，或许这是引起注意的一个好办法）： 
　　 1。如果您用 GRUB for DOS，请尽量用版本 0.0.x 的，不要用更高的。 
　　 2。如果您不用 0.0.x 的，请尽量用版本 0.1.x 的，不要用更高的。 
　　 3。如果您不用 0.1.x 的，请尽量用版本 0.2.x 的，不要用更高的。 
　　 4。如果您用 0.2.x 的版本，请尽量不要用 map 等磁盘仿真命令。 
　　 5。如果您用 0.2.x 的版本，也用了 map 命令，请尽量先在虚拟机中测试运行。 
　　 6。版本 0.2.x 在您的虚拟机中测试过了之后，在真实机器中尽量用 --read-only 等参数运行。 
　　 7。尽管已经把 map 命令加上了 --read-only 等参数，但也请尽量不要启动 Windows。 
　　 8。如果要启动 Windows，请尽量不要把用来仿真的 img 映像安置在 (hd0) 驱动器上。 
　　 9。如果启动了 Windows，即便仿真磁盘的映像不在 (hd0) 驱动器上，您也得做好最坏的打算：其一，如果仿真映像被毁，您不要感到出乎意料；其二，如果某个真实磁盘全部被毁，您不要感到难以接受；其三，如果您的所有的、全部的硬盘都报废了，您也不要感到太奇怪。 
　　 10。版本 0.2.x 以后的仿真技术是给熟练的电脑玩家作为研究的目的来使用的，不是给普通用户使用的。 
　　 11。玩家们最好互相交流经验，研究别人在使用过程中失败的情况，详细阅读说明文档，避免使自己遭受不必要的损失。 
　　 在初期的测试中暴露出很多问题，也损坏过很多硬盘，所以在这里特别通报一下，并写出了上述注意事项。 
map 命令的新功能是有某种危险的，建议首先在 VMware 或者 Virtual PC 这类虚拟机中测试。先用 --read-only 或者 --fake-write 参数运行 map 命令，这样是在只读状态下测试，安全一些。只读测试一段时间后，没有问题的话，再进行全面测试。测试时，在 grub 所仿真的虚拟磁盘上安装 DOS/Win9x/Me，不要用别的操作系统。即使全部测试都成功，这个仿真技术也仍然有着它固有的危险性。这是基于 BIOS 的仿真，不是全方位的仿真。例如，当你格式化一个磁盘的时候，你得明白这个磁盘是不是仿真了的? 以及你所用的格式化软件是使用 BIOS 呢? 还是使用磁盘 IO 端口读写? 使用 BIOS 的格式化软件，在仿真之下是安全的。使用磁盘 IO 端口的格式化软件，当它格式化一个仿真了的磁盘时，在最坏的情况下，实际上会格式化你的真实硬盘，至于说这种危险的误操作会发生在哪个硬盘上，取决于使用了什么样的 map 命令集（参考下面的“技术细节和实现方法”一节）。更进一步的测试，请大家报告 DOS 的 format 命令、Windows 资源管理器的格式化命令、磁盘碎块整理命令等等，以及第三方生产的 HD-COPY 等工具软件在进行格式化操作时是否安全。 

技术细节和实现方法： 
GRUB for DOS 0.2.x 将要对各种规格的软盘映像给以支持。由于硬盘的仿真也很类似，所以，也要对硬盘的 img 给以支持。另外，GRUB for DOS 0.2.x 也要开放写入虚拟磁盘的操作（写入虚拟盘是一种危险的操作，因为实际上我们写入了硬盘的 img 文件中，万一 GRUB for DOS 0.2.x 的仿真程序有 BUG，写入硬盘其它扇区中，可能造成数据毁损、无法启动等严重问题！）。 
对软盘规格：需要解决的技术问题是如何恰当地处理三维的几何地址，也就是平常所说的 CHS（C――磁道柱面号；H――磁头号；S――扇区号）。对于真实的软驱（和软盘），都有这些规格的。然而，我们仿真之后的 img 文件，却无法表示这些规格。例如，一个 1.44M 的没有格式化的 img 文件，里面的数据全部是 00，怎么确定其 CHS 值呢？ 
当 img 文件已经经过 DOS 的格式化时，就用软盘第一扇区的 BPB 表来确定 CHS 值。如果没有经过 DOS 的格式化，或者发现其 BPB 表是错误的，那么就根据 img 文件的大小来确定 CHS 值。如果是标准的（或者常用的）软盘 img 尺寸，如 1.44M，1.2M，2.88M 等等，就用已知的 CHS 值。我们支持的软盘尺寸甚至可以是任意的（非标准的），如 10M 或 50M 或 500M 的软盘 img 文件。这时候，如果 BPB 表中没有合法的 CHS 值，就需要用 map 命令行参数来手动设置 CHS 值了。如果命令行没有指定 CHS 值，给出一个错误信息，拒绝仿真。当软盘 BPB 表和 map 命令行都有 CHS 的指定时，以命令行的指定为准，如果两者有差别，给出一个警告信息。 
软盘规格列表(不支持扇区大小不等于 512 字节的防拷贝加密软盘): 
软盘容量　　　　每面磁道数　　　　每道扇区数　　　　磁头数或面数 
1440K(标准)　　　　80　　　　　　　　18　　　　　　　　2　　 

硬盘比软盘复杂了一些。硬盘第一扇区不是 DOS 的引导区，而是主引导记录（MBR），这里没有 BPB 表，而是有一个分区表。所以，对于硬盘的 CHS，作如下的处理： 
当没有分区表或者分区表错误时，必须由 map 命令行来指定 CHS，否则拒绝仿真。当分区表存在时，由四个分区表项中的任意一项都可以确定 H 和 S 的值。再用 img 文件长度即可确定 C 的值。【大硬盘的 CHS 值也是可以用这种办法来确定的。】 
也可能有人不愿意给出命令行 CHS 参数，他们希望 grub for dos 任意选择一个适当的值。map 命令将提供这样一种选项。首先根据上述 BPB 或分区表来确定CHS，如果失败，再用以下的办法来确定。对于软盘，尽量采用具有 2 个磁头的参数。对于硬盘 img 文件，如果让 GRUB for DOS 来自动挑选，则总是选择 63个扇区、256 个磁头。 
drive_map_slot 结构： 
字节：FROM_DRIVE――把哪个 BIOS 磁盘号映射到另外一个磁盘号或者映射到另一个 img 文件？ 
字节：TO_DRIVE――被映射到的磁盘号。BIOS 磁盘号：0，1，……表示软盘，0x80，0x81，……表示硬盘。 
字节：MAX_HEAD――最大磁头号。取值范围：0 至 255。 
字节：MAX_SECTOR――最大扇区号。取值范围：1 至 63。 
4字节：START_SECTOR――被映射到的 img 文件的起始扇区号。 
4字节：SECTOR_COUNT――被映射到的 img 文件的扇区总数。必须是偶数。 
当 MAX_SECTOR 的取值为 0 时，表示禁止常规磁盘读写中断（例如int13/AH=02）【map 的命令行参数 --disable-chs-mode】。MAX_SECTOR 的最高两位还有用。最高位为 1 表示只读操作【map 的命令行参数 --read-only 或者 --fake-write】，写入仿真软盘的扇区数据统统丢弃。次高位为 1 表示禁止扩展磁盘读写中断（例如 int13/AH=42H）【map 的命令行参数 --disable-lba-mode】。SECTOR_COUNT 是总扇区数。这个数目必须是偶数（当它为奇数时，处在末尾的一个扇区不参加仿真）。因此，SECTOR_COUNT 的最低位还有用。当该位为 1 而且 MAX_SECTOR 的最高位也为 1 时，表示“伪装写入扇区”操作【map 的命令行参数 --fake-write】。“伪装写”和“只读”是类似的，区别在于，“只读”在扔掉写入的扇区之后，告诉调用者程序说：“该盘写保护，不能写入”；而“伪装写”在扔掉写入的扇区之后，欺骗调用者程序说：“成功写入，请继续吧。”【我们有时候确实是需要这个功能的】。当 START_SECTOR 为 0 并且 SECTOR_COUNT 的高 31 位都为 0 时，表示用整个磁盘（而不是其中的一部分扇区段）来仿真【SECTOR_COUNT 的最低位表示“伪装写”】，这样仿真的效率要高一些【GNU GRUB 原来的仿真就是这样的，代码也很简单】。 

当 SECTOR_COUNT 为奇数（也即 --fake-write 置位）而 MAX_SECTOR 的最高位为 0（也即 --read-only 没有置位）时，称为 safeboot，此时虽然允许写入虚拟磁盘，但不允许写入虚拟磁盘的第一扇区（引导区）。而且如果虚拟磁盘映象是一个硬盘映象，也不允许写入第 0 柱面第 1 磁头第 1 扇区（也就是逻辑扇区号 LBA＝63 的扇区，该扇区通常是操作系统的引导扇区，例如 DOS 的 boot record）。这是对于 int13/AH=03h 来说的。程序并不禁止 int13/AH=43h （扩展写盘功能）的写入。也就是说，用 int13/AH=43h 可以写入任何扇区。 safeboot 默认时是开启的，可以使用 map 命令行参数 --unsafe-boot 来关闭它。【注：不存在 --safe-boot 选项。默认时之所以打开 safeboot，是因为曾经碰到 win98 破坏引导区的事情发生。如果您不准备启动 win98，您可以加上 --unsafe-boot 选项，从而允许 int13/AH=03h 写入引导扇区。很明显，只有在对虚拟盘进行分区以及格式化、或者运行 dos 的 sys 命令时才需要 --unsafe-boot 选项。】 
map 命令还有两个命令行参数： 
--heads-per-cylinder=NUM_HEADS 
--sectors-per-track=NUM_SECTORS 
NUM_HEADS 的取值范围是 1 至 256；NUM_SECTORS 的取值范围是 1 至 63。但它们也允许是 0，这表示用户允许 grub for dos 任意挑选一个合适的值。如果 map 的命令行没有指定 --heads-per-cylinder 以及 --sectors-per-track，那么，当 grub for dos 不能从 img 文件的第一扇区探测到一个合适的值时，会给出错误信息并拒绝仿真。 

这里指出一点限制。GRUB for DOS 扩展了原来 GNU GRUB 的仿真。GNU GRUB 原来的仿真是一种简单的仿真，只能仿真整个磁盘，不能用一部分扇区来仿真。新的仿真可以用磁盘上的部分扇区序列来仿真，但是，这个功能的实现，利用了新型 BIOS 的逻辑块寻址（LBA）功能，也就是磁盘扩展读写功能。这对于老旧的 BIOS 是无效的。所以，老的 BIOS 无法利用新的仿真功能。但 GRUB for DOS 兼容 GNU GRUB 的仿真，所以，老的 BIOS 仍然可以用 GRUB for DOS 的“用整个磁盘来仿真”的功能，这是原来 GNU GRUB 本来就有的功能，其用法在 grub for dos 中完全没有变化。 

可以在 grub> 提示符下用 help map 命令察看即时帮助信息。 
下面介绍另外几个 map 命令行参数的用法。 
map --status 这条命令显示磁盘仿真的状态，很有用。所显示的状态标题栏中，最右边的 Hk 表示 hook 的意思，其值是两位二进制数 xy，因此取值有四种：00,01,10,11。当 x 为 1 时，表示现在 grub 正在使用该虚拟磁盘。当 x 为 0 时，表示现在 grub 没有使用该虚拟磁盘。当 y 为 1 时，表示在运行 map --rehook 命令之后，grub 将使用该虚拟磁盘。当 y 为 0 时，表示在运行 map --rehook 命令之后，grub 将不使用该虚拟磁盘。 
map --status 命令所显示的其它状态值都是容易理解的，它们都是以十六进制来表示的数值。 
map --hook 这条命令用于直接在 grub 内部就开始使用仿真。通常 grub 本身是不使用仿真的，有了这条命令之后，从 grub 命令行就可以开始检验仿真的效果了。cool！关闭这个功能的命令是 map --unhook 
map --unhook 正如上面解释的，关闭 grub 的即时仿真功能。 
map --rehook 这条命令的用途：当你使用了 map --hook 命令之后，又用了新的 map 命令映射了别的磁盘，那么，你可以用 map --rehook 命令来激活全部这些仿真。这条命令等价于以下两条命令接连发出： 
map --unhook 
map --hook 
当撤销磁盘仿真时，仅仅用 map --unhook 是不够的，还需要用类似于 map (fd0) (fd0) 的命令来撤销 (fd0) 的仿真。“map --unhook”命令仅仅使得在 grub 命令行之下不再使用仿真了，当您用 boot 命令时，会自动再次 hook 上。要想使得某个 map DESTINATION FROM_DRIVE 命令彻底失效，必须用 map FROM_DRIVE FROM_DRIVE 命令来撤销它【将某个 BIOS 磁盘号码映射到它自己，就意味着撤销它】。撤销部分 BIOS 磁盘号码的仿真之后，一般还需要运行 map --rehook 命令。例如，“map (hd1) (hd1)”命令撤销了对 (hd1) 的仿真，但在运行“map --rehook”之后才起作用。 
一些遗留问题： 
1。支持从 ISO 映像文件启动。(情况复杂，有难度) 
2。支持从 CDROM 启动。(情况复杂，有难度) 
3。支持从 win98 下直接运行 grub。(技术难度高) 
4。自动探测和恢复 BIOS 中断向量，从而使 grub for dos 支持任意的实模式 DOS。(技术难度中等) 
5。在 emm386 运行时也能运行 grub for dos(首先解决从保护模式切换到实模式)。(技术难度高) 
6。解决在磁盘仿真时和 win98 的一些冲突问题。(技术难度高) 
7。增加退出到 DOS 的功能。(技术难度中等) 
8。创建一个可以生成“具有连续磁盘扇区的文件”的工具。 
